<!DOCTYPE html>
<meta charset="utf-8">
<html>
	<head>
		<title>Hoc462</title>
		<!-- Include stylesheets only here -->
	</head>
	<body>
		<canvas id="c" width="640" height="640"></canvas>
		<canvas id="minimap" width="640" height="640"></canvas>
		<!-- Please include JS libraries below this line -->
		<script>
/*
| 0: cast to integer
LINKS:
CONSUME THOSE
http://lodev.org/cgtutor/raycasting.html
http://lodev.org/cgtutor/raycasting2.html
http://lodev.org/cgtutor/raycasting3.html
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
*/
var ctx = c.getContext("2d");
var mapCtx = minimap.getContext("2d");
function canvasDebugger(contexts) {
	return contexts.map(_=>{
		var nativeBeginPath = _.beginPath.bind(_);
		var newBeginPath = (function() {
			this[1].watchDog = setTimeout(_=>console.log('Someone forgot to close path, fill or stroke'), 200);
			this[0]();
		}).bind([nativeBeginPath, _]);
		_.beginPath = newBeginPath;
		function clearWatchDogTimer() {
			clearTimeout(this[1].watchDog);
			this[0]();
		}
		var nativeFill = _.fill.bind(_);
		var newFill = clearWatchDogTimer.bind([nativeFill,_]);
		_.fill = newFill;
		var nativeStroke = _.stroke.bind(_);
		var newStroke = clearWatchDogTimer.bind([nativeStroke,_]);
		_.stroke = newStroke;
		var nativeClosePath = _.closePath.bind(_);
		var newClosePath = clearWatchDogTimer.bind([nativeClosePath,_]);
		_.closePath = newClosePath;
	});
}
var log500Times;
(function() {
	var counter = 0;
	log500Times = function() {
		if (counter < 500) {
			console.log(arguments);
		}
		counter++;
	}
})()
canvasDebugger([ctx, mapCtx]);
var MINI_MAP_SCALE = 8;
var OUTSIDE_THE_MAP = -1;
var IS_WALL = 1;
var NO_HIT = 0;
var IS_HIT = 1;
var X_HIT = 0;
var Y_HIT = 1;
var UP = 1;
var DOWN = -1;
var LEFT = -1;
var RIGHT = 1;
function drawMiniMap() {
	mapCtx.fillStyle = "white";
	mapCtx.fillRect(0, 0, minimap.width, minimap.height);
	for (var y = 0; y < player.map.height; y++)
		for (var x = 0; x < player.map.width; x++)
			if (player.map.get(x, y) == IS_WALL) {
				mapCtx.fillStyle = "rgb(200, 200, 200)";
				mapCtx.fillRect(
					x * MINI_MAP_SCALE,
					y * MINI_MAP_SCALE,
					MINI_MAP_SCALE, MINI_MAP_SCALE
				);
			}
	updateMiniMap();
}
function updateMiniMap() {
	mapCtx.fillStyle = "black";
	mapCtx.fillRect(
		player.x * MINI_MAP_SCALE - 2,
		player.y * MINI_MAP_SCALE - 2,
		4, 4
	);
	mapCtx.beginPath();
	mapCtx.moveTo(player.x * MINI_MAP_SCALE, player.y * MINI_MAP_SCALE);
	mapCtx.lineTo(
		(player.x + Math.cos(player.rot) * 4) * MINI_MAP_SCALE,
		(player.y + Math.sin(player.rot) * 4) * MINI_MAP_SCALE
	);
	mapCtx.stroke();
}
function Player() {
	this.x = 0;
	this.y = 0;
	this.dirX = 1
	this.dirY = 0; 
	this.planeX = 0
	this.planeY = 0.66;
	this.dir = 0;
	this.rot = 0;
	this.speed = 0;
	this.moveSpeed = 0.4;
	this.rotSpeed = 6 * Math.PI / 180;
	this.map = null;
	return this;
};
Player.prototype = {
	move: function() {
		var moveStep = this.speed * this.moveSpeed;
		this.rot += this.dir * this.rotSpeed;
		var newX = this.x + Math.cos(player.rot) * moveStep;
		var newY = this.y + Math.sin(player.rot) * moveStep;
		var currentMapBlock = this.map.get(newX|0, newY|0);
		if (currentMapBlock === OUTSIDE_THE_MAP || currentMapBlock > 0) {
			this.stopMoving();
			return;
		};
		this.x = newX;
		this.y = newY;
		this.rotateDirectionAndPlane(this.dir * this.rotSpeed);
		return this;
	},
	rotateDirectionAndPlane: function(angle) {
		var oldDirX = this.dirX;
		this.dirX = this.dirX * Math.cos(angle) - this.dirY * Math.sin(angle);
		this.dirY = oldDirX * Math.sin(angle) + this.dirY * Math.cos(angle);
		var oldPlaneX = this.planeX;
		this.planeX = this.planeX * Math.cos(angle) - this.planeY * Math.sin(angle);
		this.planeY = oldPlaneX * Math.sin(angle) + this.planeY * Math.cos(angle);
		this.stopMoving();
	},
	setXY: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},
	setRot: function(angle) {
		var difference = angle - this.rot;
		this.rot = angle;
		this.rotateDirectionAndPlane(difference);
		return this;

	},
	startMoving: function(direction) {
		switch (direction) {
			case "up":
				this.speed = UP; break;
			case "down":
				this.speed = DOWN; break;
			case "left":
				this.dir = LEFT; break;
			case "right":
				this.dir = RIGHT; break;
		}
		return this;
	},
	stopMoving: function() {
			this.speed = 0;
			this.dir = 0;
			return this;
	},
	castRays: function() {
		this.move();
		for (var x = 0; x < c.width; x++) {
			var cameraX = 2 * x / c.width - 1;
			var rayPosX = this.x;
			var rayPosY = this.y;
			var rayDirX = this.dirX + this.planeX * cameraX;
			var rayDirY = this.dirY + this.planeY * cameraX;
			var mapX = rayPosX | 0;
			var mapY = rayPosY | 0
			var deltaDistX = Math.sqrt(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX));
			var deltaDistY = Math.sqrt(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY));
			var stepX = 0;
			var stepY = 0;
			var sideDistX = 0;
			var sideDistY = 0;
			var wallDistance = 0;
			var side = 0; // x wall hit or y wall hit?
			if (rayDirX < 0) {
				stepX = -1;
				sideDistX = (rayPosX - mapX) * deltaDistX;
			} else {
				stepX = 1;
				sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX;
			}
			if (rayDirY < 0) {
				stepY = -1;
				sideDistY = (rayPosY - mapY) * deltaDistY;
			} else {
				stepY = 1;
				sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY;
			}
			var hit = NO_HIT;
			while (hit === NO_HIT) {
				if (sideDistX < sideDistY) {
					sideDistX += deltaDistX;
					mapX += stepX;
					side = X_HIT;
				} else {
					sideDistY += deltaDistY;
					mapY += stepY;
					side = Y_HIT;	
				}
				if (this.map.get(mapX, mapY) > 0) {hit = IS_HIT;}
			}
			if (side === X_HIT) {
				wallDistance = (mapX - rayPosX + (1 - stepX) / 2) / rayDirX;
			} else {
				wallDistance = (mapY - rayPosY + (1 - stepY) / 2) / rayDirY;
			}
			var lineHeight = (c.height / wallDistance) | 0;
			var drawStart = -lineHeight / 2 + c.height / 2;
			var drawEnd = lineHeight / 2 + c.height / 2;
			var color = this.map.wallTextures[this.map.get(mapX, mapY)];
			if (color instanceof Texture) {
				var texture = color;
				var wallX;
				if (side === X_HIT) {
					wallX = rayPosY + wallDistance * rayDirY;
				} else {
					wallX = rayPosX + wallDistance * rayDirX;
				}
				wallX -= wallX | 0;
				var textureX = (wallX * texture.image.width) | 0;
				if ((side === X_HIT && rayDirX > 0) || (side === Y_HIT && rayDirY < 0)) {
					textureX = texture.image.width - textureX - 1;
				}
				log500Times(textureX);
				ctx.drawImage(texture.image, textureX, 0, 1, texture.image.height, x, drawStart, 1, lineHeight);
				if (side === Y_HIT) {
					ctx.globalAlpha = .5;
					ctx.strokeStyle = 'black';
					ctx.beginPath();
					ctx.moveTo(x, drawStart);
					ctx.lineTo(x, drawEnd);
					ctx.stroke();
					ctx.globalAlpha = 1;
				}
			} else {
				if (side == Y_HIT) {
					color = color.map(function (_) {
						return (_ / 2) | 0; 
					});
				}
				ctx.strokeStyle = "rgb("+color[0]+", "+color[1]+", "+color[2]+")";
				ctx.beginPath();
				ctx.moveTo(x, drawStart);
				ctx.lineTo(x, drawEnd);
				ctx.stroke();
			}
		}
	}
}
function Map(wallGrid, wallTextures) {
	this.wallGrid = wallGrid;
	this.height = wallGrid.length;
	this.width = this.height === 0 ? 0 : wallGrid[0].length;
	this.wallTextures = wallTextures || {};
}
Map.prototype.get = function(x, y) {
	x = x | 0;
	y = y | 0;
	var currentMapBlock = this.wallGrid[y][x];
	if (currentMapBlock === undefined) return OUTSIDE_THE_MAP;
	return currentMapBlock;
}
function Texture(src, width, height) {
	this.image = new Image();
	this.image.src = src;
	width ? this.image.width = width : 0;
	height ? this.image.height = height : 0;
}
var player = new Player();
player.x = player.y = 3;
player.map = new Map([
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
], {'1': new Texture('walls.png')});
var keyCodes = {
	"38": "up",
	"40": "down",
	"37": "left",
	"39": "right"
}
document.addEventListener("keydown", function(e) {
	e = e || window.event;
	e.preventDefault();
	player.startMoving(keyCodes[e.keyCode]);
});
document.addEventListener("keyup", function(e) {
	e = e || window.event;
	e.preventDefault();
	player.stopMoving(keyCodes[e.keyCode]);
});
var t0 = performance.now();
var t1 = performance.now();
function renderLoop() {
	ctx.clearRect(0, 0, c.width, c.height);
	player.castRays();
}
requestAnimationFrame(function animate() {
	renderLoop();
	drawMiniMap();
	requestAnimationFrame(animate);
});
		</script>
	</body>
</html>
