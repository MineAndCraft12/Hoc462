<!DOCTYPE html>
<meta charset="utf-8">
<html>
	<head>
		<title>Hoc462</title>
		<!-- Include stylesheets only here -->
		<style>
#c {
	position: absolute;
	top: 0;
	left: 0;
	width: 100vw;
	height: 100vh;
	background-color: black;
}
#minimap {
	position: absolute;
	top: 0;
	left: 0;
}
		</style>
	</head>
	<body>
		<canvas id="c" width="640" height="640"></canvas>
		<canvas id="minimap" width="640" height="640"></canvas>
		<!-- Please include JS libraries below this line -->
		<script>
// | 0: cast to integer
var ctx = c.getContext("2d");
var mapCtx = minimap.getContext("2d");
function canvasDebugger(contexts) {
	return contexts.map(_=>{
		var nativeBeginPath = _.beginPath.bind(_);
		var newBeginPath = (function() {
			this[1].watchDog = setTimeout(_=>console.log('Someone forgot to close path, fill or stroke'), 200);
			this[0]();
		}).bind([nativeBeginPath, _]);
		_.beginPath = newBeginPath;
		function clearWatchDogTimer() {
			clearTimeout(this[1].watchDog);
			this[0]();
		}
		var nativeFill = _.fill.bind(_);
		var newFill = clearWatchDogTimer.bind([nativeFill,_]);
		_.fill = newFill;
		var nativeStroke = _.stroke.bind(_);
		var newStroke = clearWatchDogTimer.bind([nativeStroke,_]);
		_.stroke = newStroke;
		var nativeClosePath = _.closePath.bind(_);
		var newClosePath = clearWatchDogTimer.bind([nativeClosePath,_]);
		_.closePath = newClosePath;
	});
}
var log500Times;
(function() {
	var counter = 0;
	log500Times = function() {
		if (counter < 500) {
			console.log(arguments);
		}
		counter++;
	}
})()
canvasDebugger([ctx, mapCtx]);
var MINI_MAP_SCALE = 8;
var OUTSIDE_THE_MAP = -1;
var NO_HIT = 0;
var IS_HIT = 1;
var X_HIT = 0;
var Y_HIT = 1;
var UP = 1;
var DOWN = -1;
var LEFT = -1;
var RIGHT = 1;
var TEXTURED_WALL = 10;
var COLORED_WALL = 11;
var SPRITE = 12;
function drawMiniMap() {
	if (minimap.width !== player.map.width * MINI_MAP_SCALE || minimap.height !== player.map.height * MINI_MAP_SCALE) {
		minimap.width = player.map.width * MINI_MAP_SCALE;
		minimap.height = player.map.height * MINI_MAP_SCALE;
	}
	mapCtx.fillStyle = "white";
	mapCtx.fillRect(0, 0, minimap.width, minimap.height);
	for (var y = 0; y < player.map.height; y++)
		for (var x = 0; x < player.map.width; x++)
			if (player.map.get(x, y) > 0) {
				mapCtx.fillStyle = "rgb(200, 200, 200)";
				mapCtx.fillRect(
					x * MINI_MAP_SCALE,
					y * MINI_MAP_SCALE,
					MINI_MAP_SCALE, MINI_MAP_SCALE
				);
			}
	updateMiniMap();
}
function updateMiniMap() {
	player.map.sprites.forEach(function(sprite) {
		mapCtx.fillStyle = "rgb(0, 200, 200)";
		mapCtx.fillRect(
			sprite.x * MINI_MAP_SCALE,
			sprite.z * MINI_MAP_SCALE,
			MINI_MAP_SCALE, MINI_MAP_SCALE
		);
		mapCtx.fillStyle = "black";
		mapCtx.fillRect(
			player.x * MINI_MAP_SCALE - 2,
			player.y * MINI_MAP_SCALE - 2,
			4, 4
		);
	});
	mapCtx.beginPath();
	mapCtx.moveTo(player.x * MINI_MAP_SCALE, player.y * MINI_MAP_SCALE);
	mapCtx.lineTo(
		(player.x + Math.cos(player.rot) * 4) * MINI_MAP_SCALE,
		(player.y + Math.sin(player.rot) * 4) * MINI_MAP_SCALE
	);
	mapCtx.stroke();
}
function Player() {
	this.x = 0;
	this.y = 0;
	this.dirX = 1
	this.dirY = 0; 
	this.planeX = 0;
	this.planeY = 0.66;
	this.dir = 0;
	this.rot = 0;
	this.speed = 0;
	this.moveSpeed = 0.4;
	this.rotSpeed = 6 * Math.PI / 180;
	this.map = null;
	return this;
};
Player.prototype = {
	move: function() {
		var moveStep = this.speed * this.moveSpeed;
		this.rot += this.dir * this.rotSpeed;
		var newX = this.x + Math.cos(player.rot) * moveStep;
		var newY = this.y + Math.sin(player.rot) * moveStep;
		var currentMapBlock = this.map.get(newX|0, newY|0);
		if (currentMapBlock === OUTSIDE_THE_MAP || currentMapBlock > 0) {
			this.stopMoving();
			return;
		};
		this.x = newX;
		this.y = newY;
		this.rotateDirectionAndPlane(this.dir * this.rotSpeed);
		return this;
	},
	rotateDirectionAndPlane: function(angle) {
		var oldDirX = this.dirX;
		this.dirX = this.dirX * Math.cos(angle) - this.dirY * Math.sin(angle);
		this.dirY = oldDirX * Math.sin(angle) + this.dirY * Math.cos(angle);
		var oldPlaneX = this.planeX;
		this.planeX = this.planeX * Math.cos(angle) - this.planeY * Math.sin(angle);
		this.planeY = oldPlaneX * Math.sin(angle) + this.planeY * Math.cos(angle);
		this.stopMoving();
	},
	setXY: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},
	setRot: function(angle) {
		var difference = angle - this.rot;
		this.rot = angle;
		this.rotateDirectionAndPlane(difference);
		return this;

	},
	startMoving: function(direction) {
		switch (direction) {
			case "up":
				this.speed = UP; break;
			case "down":
				this.speed = DOWN; break;
			case "left":
				this.dir = LEFT; break;
			case "right":
				this.dir = RIGHT; break;
		}
		return this;
	},
	stopMoving: function() {
			this.speed = 0;
			this.dir = 0;
			return this;
	},
	castRays: function() {
		this.move();
		var zBuffer = [];
		for (var x = 0; x < c.width; x++) {
			var cameraX = 2 * x / c.width - 1;
			var rayPosX = this.x;
			var rayPosY = this.y;
			var rayDirX = this.dirX + this.planeX * cameraX;
			var rayDirY = this.dirY + this.planeY * cameraX;
			var mapX = rayPosX | 0;
			var mapY = rayPosY | 0
			var deltaDistX = Math.sqrt(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX));
			var deltaDistY = Math.sqrt(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY));
			var stepX = 0;
			var stepY = 0;
			var sideDistX = 0;
			var sideDistY = 0;
			var wallDistance = 0;
			var side = 0; // x wall hit or y wall hit?
			var giveUp = false;
			zBuffer.push({});
			var currentBuffer = zBuffer[zBuffer.length - 1];
			if (rayDirX < 0) {
				stepX = -1;
				sideDistX = (rayPosX - mapX) * deltaDistX;
			} else {
				stepX = 1;
				sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX;
			}
			if (rayDirY < 0) {
				stepY = -1;
				sideDistY = (rayPosY - mapY) * deltaDistY;
			} else {
				stepY = 1;
				sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY;
			}
			var hit = NO_HIT;
			while (hit === NO_HIT) {
				if (sideDistX < sideDistY) {
					sideDistX += deltaDistX;
					mapX += stepX;
					side = X_HIT;
				} else {
					sideDistY += deltaDistY;
					mapY += stepY;
					side = Y_HIT;	
				}
				var currentMapBlock = this.map.get(mapX, mapY);
				if (currentMapBlock === OUTSIDE_THE_MAP || currentMapBlock > 0) {
					hit = IS_HIT;
				}
				if (currentMapBlock === OUTSIDE_THE_MAP) {
					giveUp = true;
				}
			}
			if (giveUp) {continue;}
			currentBuffer.side = side;
			if (side === X_HIT) {
				wallDistance = (mapX - rayPosX + (1 - stepX) / 2) / rayDirX;
			} else {
				wallDistance = (mapY - rayPosY + (1 - stepY) / 2) / rayDirY;
			}
			var lineHeight = (c.height / wallDistance) | 0;
			var drawStart = -lineHeight / 2 + c.height / 2;
			var drawEnd = lineHeight / 2 + c.height / 2;
			currentBuffer.start = drawStart;
			currentBuffer.end = drawEnd;
			currentBuffer.x = x; 
			currentBuffer.distance = wallDistance;
			var color = this.map.wallTextures[this.map.get(mapX, mapY)];
			if (color instanceof Texture) {
				currentBuffer.type = TEXTURED_WALL;
				var texture = color;
				currentBuffer.texture = texture;
				var wallX;
				if (side === X_HIT) {
					wallX = rayPosY + wallDistance * rayDirY;
				} else {
					wallX = rayPosX + wallDistance * rayDirX;
				}
				wallX -= wallX | 0;
				var textureX = (wallX * texture.image.width) | 0;
				if ((side === X_HIT && rayDirX > 0) || (side === Y_HIT && rayDirY < 0)) {
					textureX = texture.image.width - textureX - 1;
				}
				currentBuffer.textureX = textureX;
			} else {
				currentBuffer.type = COLORED_WALL;
				currentBuffer.color = color;
			}
			var self = this;
			this.map.sprites.forEach(function(sprite) {
				zBuffer.push({});
				var currentBuffer = zBuffer[zBuffer.length - 1];
				currentBuffer.type = SPRITE;
				currentBuffer.sprite = sprite;
				var spriteX = sprite.x - self.x;
				var spriteY = sprite.z - self.y;
				var invDet = 1.0 / (self.planeX * self.dirY - self.dirX * self.planeY);
				var transformX = invDet * (self.dirY * spriteX - self.dirX * spriteY);
				var transformY = invDet * (-self.planeY * spriteX + self.planeX * spriteY);
				if (transformY < 0) {delete currentBuffer} else {
					var spriteScreenX = ((c.width / 2) * (1 + transformX / transformY)) | 0;
					var spriteHeight = Math.abs((c.height / (transformY)) | 0);
					var drawStartY = -spriteHeight / 2 + c.height / 2;
					var drawEndY = spriteHeight / 2 + c.height / 2;
					var spriteWidth = Math.abs((c.height / (transformY)) | 0);
					var drawStartX = -spriteWidth / 2 + spriteScreenX;
					var drawEndX = spriteWidth / 2 + spriteScreenX;
					currentBuffer.distance = transformY;
					currentBuffer.width = spriteWidth;
					currentBuffer.height = spriteHeight;
					currentBuffer.drawX = drawStartX;
					currentBuffer.drawY = drawStartY;
				}
			});
		}
		return zBuffer.sort(function(a, b) {return b.distance - a.distance;});
	},
	render: function(zBuffer) {
		zBuffer.forEach(function(currentBuffer) {
			var side = currentBuffer.side;
			var drawStart = currentBuffer.start;
			var drawEnd = currentBuffer.end;
			var lineHeight = drawEnd - drawStart;
			if (currentBuffer.type === TEXTURED_WALL) {
				var texture = currentBuffer.texture;
				var textureX = currentBuffer.textureX;
				var x = currentBuffer.x;
				ctx.drawImage(texture.image, textureX, 0, 1, texture.image.height, x, drawStart, 1, lineHeight);
				if (side === Y_HIT) {
					ctx.globalAlpha = .5;
					ctx.strokeStyle = 'black';
					ctx.beginPath();
					ctx.moveTo(x, drawStart);
					ctx.lineTo(x, drawEnd);
					ctx.stroke();
					ctx.globalAlpha = 1;
				}
			} else if (currentBuffer.type === COLORED_WALL) {
				var color = currentBuffer.color;
				if (side == Y_HIT) {
					color = color.map(function (_) {
						return (_ / 2) | 0; 
					});
				}
				ctx.strokeStyle = "rgb("+color[0]+", "+color[1]+", "+color[2]+")";
				ctx.beginPath();
				ctx.moveTo(x, drawStart);
				ctx.lineTo(x, drawEnd);
				ctx.stroke();
			} else if (currentBuffer.type === SPRITE) {
				var dist = currentBuffer.distance;
				var drawX = currentBuffer.drawX;
				var drawY = currentBuffer.drawY;
				var width = currentBuffer.width;
				var height = currentBuffer.height;
				ctx.drawImage(currentBuffer.sprite.texture.image, drawX, drawY, width, height);
			}
		});
	}
}
function Map(wallGrid, wallTextures, sprites) {
	this.wallGrid = wallGrid;
	this.height = wallGrid.length;
	this.width = this.height === 0 ? 0 : wallGrid[0].length;
	this.wallTextures = wallTextures || {};
	this.sprites = sprites || [];
}
Map.prototype.get = function(x, y) {
	x = x | 0;
	y = y | 0;
	var currentMapBlock = this.wallGrid[y];
	if (currentMapBlock === undefined) return OUTSIDE_THE_MAP;
	currentMapBlock = currentMapBlock[x];
	if (currentMapBlock === undefined) return OUTSIDE_THE_MAP;
	return currentMapBlock;
}
function Texture(src, width, height) {
	this.image = new Image();
	this.image.src = src;
	width ? this.image.width = width : 0;
	height ? this.image.height = height : 0;
}
function Sprite(texture, x, y, z) {
	this.texture = texture;
	this.x = x;
	this.y = y;
	this.z = z;
}
var player = new Player();
player.x = player.y = 3;
player.map = new Map([
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
], {'1': new Texture('walls.png')},[new Sprite(new Texture('walls.png'), 4, 0, 4)]);
var keyCodes = {
	"38": "up",
	"40": "down",
	"37": "left",
	"39": "right"
}
document.addEventListener("keydown", function(e) {
	e = e || window.event;
	player.startMoving(keyCodes[e.keyCode]);
});
document.addEventListener("keyup", function(e) {
	e = e || window.event;
	player.stopMoving(keyCodes[e.keyCode]);
});
var isDragging = false;
c.addEventListener("mousedown", startDragging);
window.addEventListener("mouseup", endDragging);
c.addEventListener("touchstart", startDragging);
c.addEventListener("touchend", endDragging);
c.addEventListener("mousemove", whileDragging);
c.addEventListener("touchmove", whileDragging);
var mouseX = 0;
var pmouseX = 0;
var mouseY = 0;
var pmouseY = 0;
function whileDragging(e) {
	var event;
	e.preventDefault();
	if (e.touches) {
		event = e.touches[0];
	} else {
		event = e;
	}
	pmouseX = mouseX;
	pmouseY = mouseY;
	mouseX = event.pageX - c.offsetLeft;
	mouseY = event.pageY - c.offsetTop;
	if (isDragging) {
		player.setRot(player.rot + (mouseX - pmouseX) / c.width * 2);
		player.speed = -(mouseY - pmouseY) / c.height * 15;
	}
}
function startDragging(e) {
	var event;
	e.preventDefault();
	if (e.touches) {
		event = e.touches[0];
	} else {
		event = e;
	}
	mouseX = event.pageX - c.offsetLeft;
	mouseY = event.pageY - c.offsetTop;
	isDragging = true;
}
function endDragging(e) {
	e.preventDefault();
	isDragging = false;
}
function renderLoop() {
	ctx.clearRect(0, 0, c.width, c.height);
	player.render(player.castRays());
}
requestAnimationFrame(function animate() {
	if (c.clientWidth !== c.width || c.clientHeight !== c.height) {
		c.width = c.clientWidth;
		c.height = c.clientHeight;
	}
	renderLoop();
	drawMiniMap();
	requestAnimationFrame(animate);
});
		</script>
	</body>
</html>
